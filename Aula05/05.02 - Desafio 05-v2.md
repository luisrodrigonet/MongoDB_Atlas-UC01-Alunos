# Desafio 5: AgregaÃ§Ãµes e Ãndices no MongoDB Atlas

> ## Objetivo:
> 
> Criar pipelines de agregaÃ§Ã£o para responder Ã s seguintes perguntas:
> 
> 1. **"Qual Ã© o total de vendas por categoria de produto?"**
> 2. **"Qual Ã© o cliente que mais gastou nos Ãºltimos 3 meses?"**
> 
> E depois, comparar o tempo de execuÃ§Ã£o das consultas **antes e depois da criaÃ§Ã£o de Ã­ndices** nos campos mais usados.
> 
> ---
>


## :one: SuposiÃ§Ãµes sobre a Estrutura do Banco de Dados

Para este guia, vamos supor que vocÃª tem uma coleÃ§Ã£o chamada `vendas` com documentos no seguinte formato:

```json
{
  "_id": ObjectId("..."),
  "cliente_id": "C1001",
  "nome_cliente": "JoÃ£o Silva",
  "produto": {
    "categoria": "EletrÃ´nicos",
    "nome": "Smartphone",
    "preco": 2500.00
  },
  "quantidade": 2,
  "data_venda": ISODate("2024-11-15T08:30:00Z")
}
```

Se vocÃª nÃ£o tiver dados reais, pode usar essa estrutura como base para simular ou importar dados fictÃ­cios.


## Passo 1: Pipeline de AgregaÃ§Ã£o 

### ğŸ“Œ Objetivo:
- Calcular o total de vendas (soma dos valores) agrupadas por **categoria de produto**.

### ğŸ’¡ LÃ³gica:
- Extrair a **categoria** de cada venda.
- Calcular o valor total por venda (`preÃ§o * quantidade`).
- Agrupar pelo campo `categoria`.
- Somar os totais de venda por categoria.

### ğŸ§ª Comando do MongoDB:

```javascript
db.vendas.aggregate([
  {
    $addFields: {
      "valor_total": { $multiply: ["$produto.preco", "$quantidade"] }
    }
  },
  {
    $group: {
      _id: "$produto.categoria",
      total_vendas: { $sum: "$valor_total" }
    }
  },
  {
    $sort: { total_vendas: -1 }
  }
])
```

**SaÃ­da**:

```js
[
  { _id: 'EletrÃ´nicos', total_vendas: 9499.7 },
  { _id: 'Esportes', total_vendas: 3779.4 },
  { _id: 'MÃ³veis', total_vendas: 3759.7 },
  { _id: 'Games', total_vendas: 3699.5 },
  { _id: 'EletrodomÃ©sticos', total_vendas: 3698.9 },
  { _id: 'InformÃ¡tica', total_vendas: 3599.2 },
  { _id: 'Roupas', total_vendas: 1848.2000000000003 },
  { _id: 'Automotivo', total_vendas: 1579.3 },
  { _id: 'Beleza', total_vendas: 1204.5 },
  { _id: 'DecoraÃ§Ã£o', total_vendas: 1039.2 },
  { _id: 'Cozinha', total_vendas: 899.7 },
  { _id: 'Pets', total_vendas: 578.8 },
  { _id: 'Brinquedos', total_vendas: 499.6 },
  { _id: 'Livros', total_vendas: 367.2 },
  { _id: 'SaÃºde', total_vendas: 359.70000000000005 },
  { _id: 'Alimentos', total_vendas: 171.9 },
  { _id: 'Higiene', total_vendas: 163.5 },
  { _id: 'Limpeza', total_vendas: 123.4 },
  { _id: 'Bebidas', total_vendas: 83.4 }
]
```

### ğŸ” ExplicaÃ§Ã£o:

| Etapa | O que faz |
|-------|-----------|
| `$addFields` | Adiciona um novo campo chamado `valor_total`, calculado como `preÃ§o * quantidade`. |
| `$group` | Agrupa os documentos pela categoria (`produto.categoria`) e soma os `valor_total`. |
| `$sort` | Ordena os resultados do maior para o menor total de vendas. |


## Passo 2: Pipeline de AgregaÃ§Ã£o

### ğŸ“Œ Objetivo:
- Identificar qual cliente gastou mais dinheiro nos **Ãºltimos 3 meses**.

### ğŸ’¡ LÃ³gica:
- Filtrar apenas as vendas com data maior que **3 meses atrÃ¡s**.
- Calcular o valor total por venda (`preÃ§o * quantidade`).
- Agrupar por cliente (`cliente_id` ou `nome_cliente`).
- Somar os totais gastos por cliente.
- Ordenar do maior para o menor gasto.

### ğŸ§ª Comando do MongoDB:

```javascript
// Calcula a data de 3 meses atrÃ¡s
var tresMesesAtras = new Date();
tresMesesAtras.setMonth(tresMesesAtras.getMonth() - 3);

db.vendas.aggregate([
  {
    $match: {
      "data_venda": { $gte: tresMesesAtras }
    }
  },
  {
    $addFields: {
      "valor_total": { $multiply: ["$produto.preco", "$quantidade"] }
    }
  },
  {
    $group: {
      _id: "$cliente_id",
      nome_cliente: { $first: "$nome_cliente" },
      total_gasto: { $sum: "$valor_total" }
    }
  },
  {
    $sort: { total_gasto: -1 }
  },
  {
    $limit: 1
  }
])
```

SaÃ­da:

```js
[
  {
    _id: 'C1035',
    nome_cliente: 'AndrÃ© LuÃ­s',
    total_gasto: 53.400000000000006
  }
]
```


### ğŸ” ExplicaÃ§Ã£o:

| Etapa | O que faz |
|-------|-----------|
| `var tresMesesAtras` | Define a data limite para filtrar vendas recentes. |
| `$match` | Filtra apenas as vendas ocorridas nos Ãºltimos 3 meses. |
| `$addFields` | Calcula o valor total por venda. |
| `$group` | Agrupa por cliente e soma os gastos. |
| `$sort` | Ordena do maior gasto para o menor. |
| `$limit` | Retorna apenas o primeiro resultado (cliente com maior gasto). |

---

## ğŸ“ˆ Passo 3: Ãndices para Melhorar Desempenho

### ğŸ“Œ Por que criar Ã­ndices?

Ãndices aceleram buscas em grandes volumes de dados, especialmente nas etapas de filtragem (`$match`).

### ğŸ” Quais campos sÃ£o mais usados?
- `produto.categoria` â†’ usado em `$group`
- `cliente_id` â†’ usado em `$group`
- `data_venda` â†’ usado em `$match` (filtros por data)

### ğŸ“Œ Como medir o tempo de execuÃ§Ã£o?

No MongoDB, podemos usar o mÃ©todo `.explain()` para ver detalhes de execuÃ§Ã£o, incluindo tempo estimado.

 **ğŸ§ª Exemplo com `.explain()`**:

```javascript
db.vendas.aggregate([...], { explain: true })
```

Ou no MongoDB Compass:

1. Execute o pipeline de agregaÃ§Ã£o.
2. Clique em **Explain Plan**.
3. Compare o tempo antes e depois de criar os Ã­ndices.

 
 **ğŸ§ª Exemplo com calculo manual**:

Outra forma de realizar a comparaÃ§Ã£o Ã© calculando manualmente o tempo, como no exemplo abaixo:

```javascript
const start = new Date();

db.produtos.find({ preco: { $gt: 100 } }).toArray();

const end = new Date() - start;
print(`Tempo antes do Ã­ndice: ${end} ms`);

// SaÃ­da possÃ­vel:
// Tempo antes do Ã­ndice: 120 ms
```


### ğŸ“Š Resultado esperado:

ApÃ³s criar os Ã­ndices:
- As operaÃ§Ãµes de filtragem (`$match`) serÃ£o mais rÃ¡pidas.
- A performance geral do pipeline aumentarÃ¡, principalmente com grandes quantidades de dados.

## ğŸ“ˆ Passo 4: Criar Ãndices para Melhorar Desempenho

### ğŸ§ª Comandos para criar Ã­ndices:

#### 1. Ãndice composto para datas de venda:

```javascript
db.vendas.createIndex({ "data_venda": 1 })
```

#### 2. Ãndice para categorias de produtos:

```javascript
db.vendas.createIndex({ "produto.categoria": 1 })
```

#### 3. Ãndice para clientes:

```javascript
db.vendas.createIndex({ "cliente_id": 1 })
```

#### 4. Ãndice multiplos campos:

VocÃª tambÃ©m pode criar um Ã­ndice composto se quiser otimizar mÃºltiplos campos juntos.

 Por exemplo, o comando abaixo cria um Ã­ndice composto nos campos `cliente_id` e `data_venda`:

```javascript
db.clientes.createIndex({ cliente_id: 1, data_venda: 1 })
```


## ğŸ‘¥ InteraÃ§Ã£o em Grupo

### ğŸ’¬ Atividade em Dupla:

1. Formem duplas.
2. Cada dupla deve executar os dois pipelines criados acima.
3. Discutam:
   - O que cada etapa do pipeline faz?
   - Como os dados foram transformados ao longo do pipeline?
   - Qual foi a diferenÃ§a de desempenho apÃ³s criar os Ã­ndices?

### ğŸ—£ï¸ ApresentaÃ§Ã£o em Grupo:

- Cada dupla compartilha suas descobertas.
- Discutam juntos:
   - Como os Ã­ndices ajudaram?
   - Quais outros campos poderiam ser indexados?
   - Em quais cenÃ¡rios essas consultas poderiam ser Ãºteis na vida real?

---

# ğŸ“š Resumo Final

| TÃ³pico | Detalhe |
|--------|---------|
| **Pipeline de AgregaÃ§Ã£o** | Ferramenta poderosa do MongoDB para processar e analisar dados. |
| **Etapa `$match`** | Filtra documentos antes de continuar no pipeline (reduz custo). |
| **Etapa `$group`** | Agrupa documentos com base em um campo e aplica acumuladores (como `$sum`). |
| **Etapa `$sort`** | Ordena os resultados. |
| **Etapa `$addFields`** | Adiciona novos campos calculados. |
| **Ãndices** | Melhoram significativamente o desempenho de consultas. |
| **MongoDB Atlas** | Interface web para gerenciar bancos de dados MongoDB na nuvem. |

